    // this goes left -> right

//     for (int j = 0; j < M; j += blocksize) { // col block increaser
//       for (int i = 0; i < N; i += blocksize) { // row block increaser
//         // skip the first row
//         // THIS ASSUMES EVEN DIMENSIONS!!!!!!!!!!!!!
//           for (int ii = i; ii < i + blocksize; ii += 2) {
//               for (int jj = j; jj < j + blocksize; jj += 2) {
//                   B[jj][ii] = A[ii][jj];
//                   if (ii + 1 < i + blocksize && jj + 1 < j + blocksize) {
//                     B[jj][ii + 1] = A[ii + 1][jj];
//                     B[jj + 1][ii] = A[ii][jj + 1];
//                     B[jj + 1][ii + 1] = A[ii + 1][jj + 1];
//                   }
                  
//               }
//           }
//           // much worse
//         //   for (int jj = 0;  jj < j + blocksize; jj++) {
//         //     B[jj][0] = A[0][jj];
//         //   }
//       }
//    
//   }

//   for (int j = 0; j < M; j += blocksize) { // col block increaser
//       for (int i = 0; i < N; i += blocksize) { // row block increaser
//         // THIS ASSUMES EVEN DIMENSIONS!!!!!!!!!!!!!
//           for (int ii = i; ii < i + blocksize; ii += 2) {
//               for (int jj = j; jj < j + blocksize; jj += 2) {
//                   B[jj][ii] = A[ii][jj];
//                   B[jj][ii + 1] = A[ii + 1][jj];
//                   B[jj + 1][ii] = A[ii][jj + 1];
//                   B[jj + 1][ii + 1] = A[ii + 1][jj + 1];
//               }
//           }
//       }
//   }

// still worse even with different access pattern
  // THIS ASSUMES EVEN DIMENSIONS!!!!!!!!!!!!!
        //   for (int ii = i; ii < i + blocksize; ii += 2) {
        //       for (int jj = j; jj < j + blocksize; jj += 2) {
        //           B[jj][ii] = A[ii][jj];
        //           B[jj][ii + 1] = A[ii + 1][jj];
        //           B[jj + 1][ii] = A[ii][jj + 1];
        //           B[jj + 1][ii + 1] = A[ii + 1][jj + 1];
        //       }
        //   }




void blocker(int M, int N, int A[N][M], int B[M][N]) {

    int last_size = N; // we are assuming M == N here!
    int row;
    int col; 
    int for_row = 0;
    int for_col = 0;

     for (int log = (N / 2); log > 0; log /= 2) { // N = 8, iterate 4, 2, 1 -- 3 times
        printf("log is %d\n", log);

        // will iterate 1, then 2, then 4...
        for (int starting_place = 0; starting_place < N - 1; starting_place += last_size) { // size to jump for next block

          for (int row_counter = 0; row_counter < log; row_counter++) { // needs to iterate 4 times
          // row = log + jumper + (test % log); // + col _ shifter
        
              printf("starter is %d\n", starting_place);

              // always start with log, offset by the jump, and through how many "last rows" we have
              row = log + starting_place + (row_counter % log); 

              // now, the columns...
              // i guess we can just have its own jumper
              for (int col_jumper = 0; col_jumper < N - 1; col_jumper += last_size) { // size to jump for next block
                for(int col_counter = 0; col_counter < log; col_counter++) { // 0 -> 4, 0 -> 2, 0 -> 1
                    printf("iterator inner is %d\n", col_counter);
                      
                    col = col_jumper + (col_counter % log);
                      
                    printf("ACCESSING B: (%d, %d)\n", row, col);
                    B[row][col] = A[col][row];
                    B[col][row] = A[row][col];
                  // for_col++;
                }
                // for_col = 0;
              // // test++
              // for_row++; 
              }
            }
            // test = 0;
            // for_row = 0;
            
        }
        last_size /= 2;
        
    }


   

    // for (int log = (N / 2); log > 0; log /= 2) { // N = 8, iterate 4, 2, 1 -- 3 times
    //     printf("log is %d\n", log);

        
    //     for (int jumper = 0; jumper < N - 1; jumper += last_size) { // size to jump for next block

    //       for (int grab_per_row = 0; grab_per_row < 4; grab_per_row++) { // needs to iterate 4 times
    //       // row = log + jumper + (test % log); // + col _ shifter
          

    //           printf("jumper is %d\n", jumper);

    //           row = log + jumper + (for_row % log);
    //           // issue, need to stay on that row for longer


    //           for(int col_shifter = 0; col_shifter < 4; col_shifter++) { // 0 -> 4, 0 -> 2, 0 -> 1
    //               printf("iterator inner is %d\n", col_shifter);
                    
    //               col = jumper + (for_col % log);
                    
    //               printf("ACCESSING B: (%d, %d)\n", row, col);
    //               B[row][col] = A[col][row];
    //               B[col][row] = A[row][col];
    //             for_col++;
    //           }
    //           for_col = 0;
    //           // test++
    //           for_row++; 
    //         }
    //         // test = 0;
    //         for_row = 0;
            
    //     }
    //     last_size /= 2;
        
    // }

} // end method